/* Generated by Yosys 0.45 (git sha1 9ed031ddd, g++ 11.2.0 -fPIC -O3) */

(* top =  1  *)
(* src = "src/fsm.sv:1.1-50.10" *)
module fsm(CLK, nRST, data, accept);
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  (* src = "src/fsm.sv:2.11-2.14" *)
  input CLK;
  wire CLK;
  (* src = "src/fsm.sv:4.12-4.18" *)
  output accept;
  wire accept;
  (* src = "src/fsm.sv:3.11-3.15" *)
  input data;
  wire data;
  (* src = "src/fsm.sv:2.16-2.20" *)
  input nRST;
  wire nRST;
  (* enum_type = "$enum0" *)
  (* enum_value_000 = "\\S0" *)
  (* enum_value_001 = "\\S1" *)
  (* enum_value_010 = "\\S2" *)
  (* enum_value_011 = "\\S3" *)
  (* enum_value_100 = "\\S4" *)
  (* src = "src/fsm.sv:20.20-20.24" *)
  (* wiretype = "\\state_t" *)
  wire [2:0] next;
  (* enum_type = "$enum0" *)
  (* enum_value_000 = "\\S0" *)
  (* enum_value_001 = "\\S1" *)
  (* enum_value_010 = "\\S2" *)
  (* enum_value_011 = "\\S3" *)
  (* enum_value_100 = "\\S4" *)
  (* src = "src/fsm.sv:20.13-20.18" *)
  (* wiretype = "\\state_t" *)
  reg [2:0] state;
  assign _12_ = ~state[2];
  assign _00_ = ~state[0];
  assign _01_ = ~data;
  assign _02_ = state[2] | state[1];
  assign accept = ~(state[0] | _02_);
  assign _03_ = state[1] & _01_;
  assign _04_ = _12_ & state[0];
  assign _05_ = ~(_12_ & state[0]);
  assign _06_ = _12_ & state[1];
  assign _07_ = ~(_12_ | state[1]);
  assign _08_ = ~(state[0] | data);
  assign _09_ = ~(_07_ & _08_);
  assign _10_ = ~((_03_ & _04_) | (_07_ & _08_));
  assign next[0] = ~((_01_ | _02_) & _10_);
  assign next[1] = ~((_03_ | _05_) & _09_);
  assign _11_ = data ? _07_ : _06_;
  assign next[2] = _00_ & _11_;
  (* \always_ff  = 32'd1 *)
  (* src = "src/fsm.sv:23.5-29.8" *)
  always @(posedge CLK, negedge nRST)
    if (!nRST) state[0] <= 1'h0;
    else state[0] <= next[0];
  (* \always_ff  = 32'd1 *)
  (* src = "src/fsm.sv:23.5-29.8" *)
  always @(posedge CLK, negedge nRST)
    if (!nRST) state[1] <= 1'h0;
    else state[1] <= next[1];
  (* \always_ff  = 32'd1 *)
  (* src = "src/fsm.sv:23.5-29.8" *)
  always @(posedge CLK, negedge nRST)
    if (!nRST) state[2] <= 1'h0;
    else state[2] <= next[2];
endmodule
